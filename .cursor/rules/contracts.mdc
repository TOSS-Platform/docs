---
alwaysApply: false
---
# Smart Contract Development Rules

## Documentation Adherence Rule

**CRITICAL**: Contract development MUST strictly follow documentation. Any deviation requires approval and documentation updates.

### Rule

1. **Before Implementation**: Review contract documentation thoroughly
2. **During Development**: If documentation differs from implementation needs, ASK before proceeding
3. **After Implementation**: Verify all documented features are implemented
4. **Documentation Updates**: Update all related documentation when changes are made

### Requirements

#### 1. Pre-Implementation Review

Before starting contract development:

- [ ] Read complete contract documentation
- [ ] Understand all documented features and requirements
- [ ] Identify dependencies and relationships
- [ ] Note any unclear or ambiguous specifications
- [ ] Ask questions if documentation is unclear

#### 2. Deviation Approval Process

If you need to implement something NOT in the documentation:

**STOP and ASK**:
- Do NOT implement undocumented features without approval
- Explain why the deviation is needed
- Propose the change clearly
- Wait for approval before proceeding

**After Approval**:
- Implement the approved change
- Update contract documentation immediately
- Update all related documentation:
  - Contract specification document
  - Integration guides
  - API documentation
  - User guides (if applicable)
  - Test documentation

#### 3. Documentation Update Requirements

When making ANY change to a contract:

**Required Updates**:
1. **Contract Documentation** (`docs/docs/protocol/contracts/{category}/{ContractName}.md`)
   - Update function specifications
   - Update state variables
   - Update events
   - Update access control
   - Update error conditions

2. **Related Documentation**:
   - Integration guides
   - API documentation
   - Deployment guides
   - Testing documentation
   - User documentation (if applicable)

3. **Code Comments**:
   - Update NatSpec comments
   - Update inline comments
   - Ensure comments match implementation

#### 4. Post-Implementation Verification

After contract is complete, verify:

- [ ] All documented functions are implemented
- [ ] All documented events are emitted
- [ ] All documented state variables exist
- [ ] All documented access controls are enforced
- [ ] All documented error conditions are handled
- [ ] All documented workflows are supported
- [ ] Implementation matches documentation exactly
- [ ] No undocumented features exist (unless approved)

### Verification Checklist

Before marking contract as "complete":

**Documentation Verification**:
- [ ] Contract matches specification document
- [ ] All functions documented in spec are implemented
- [ ] All events documented in spec are emitted
- [ ] All state variables documented in spec exist
- [ ] All access controls documented in spec are enforced
- [ ] All error conditions documented in spec are handled
- [ ] No undocumented features (unless explicitly approved)
- [ ] Documentation updated for any approved deviations

**Related Documentation Verification**:
- [ ] Integration guides updated
- [ ] API documentation updated
- [ ] Deployment guides updated
- [ ] Test documentation updated
- [ ] User documentation updated (if applicable)

**Code-Documentation Alignment**:
- [ ] NatSpec comments match implementation
- [ ] Function signatures match documentation
- [ ] Event definitions match documentation
- [ ] Error messages match documentation
- [ ] Access control matches documentation

### Example Workflow

#### Scenario 1: Following Documentation

```typescript
// Documentation says: "Function should transfer tokens"
// Implementation:
function transfer(address to, uint256 amount) external {
  // Implementation matches documentation exactly
  _transfer(msg.sender, to, amount);
}
```

#### Scenario 2: Deviation Needed

```typescript
// Documentation says: "Function should transfer tokens"
// But you need to add: "with fee deduction"
// 
// STOP: Ask for approval
// "I need to add fee deduction to transfer function. 
//  Should I proceed? This will require documentation update."
//
// After approval:
// 1. Implement with fee deduction
// 2. Update contract documentation
// 3. Update integration guides
// 4. Update API documentation
```

#### Scenario 3: Post-Implementation Verification

```typescript
// After contract is complete:
// 1. Compare implementation with documentation
// 2. List all functions in documentation
// 3. Verify each is implemented
// 4. List all functions in implementation
// 5. Verify each is documented (or approved deviation)
// 6. Update any mismatches
```

### Documentation Locations

Contract documentation is located in:
- `docs/docs/protocol/contracts/{category}/{ContractName}.md`
- Example: `docs/docs/protocol/contracts/core/TOSS.md`

Related documentation:
- Integration guides: `docs/docs/protocol/integration/`
- API documentation: `docs/docs/api/`
- User guides: `docs/docs/user-guides/`
- Testing docs: `docs/docs/technical/testing/`

### Enforcement

- Code review will verify documentation adherence
- PRs with undocumented features (without approval) will be rejected
- PRs missing documentation updates will be requested to add them
- Post-implementation verification is mandatory before marking contract as "complete"

### Checklist Template

When developing a contract:

**Pre-Development**:
- [ ] Documentation reviewed
- [ ] All requirements understood
- [ ] Questions asked if unclear

**During Development**:
- [ ] Any deviation? → ASK for approval
- [ ] Approved deviation? → Update documentation immediately

**Post-Development**:
- [ ] All documented features implemented
- [ ] No undocumented features (unless approved)
- [ ] Documentation updated for any changes
- [ ] Related documentation updated
- [ ] Verification completed

## Playground Maintenance Rule

**CRITICAL**: When adding a new contract to the TOSS Protocol, you MUST also add playground support for it.

### Rule

Every new contract that is deployed and integrated into the protocol MUST have corresponding playground functionality added to `scripts/playground/`.

### Requirements

1. **New Contract Playground Class**: Create a new playground class following the pattern of `TOSSPlayground.ts`
   - Location: `scripts/playground/{ContractName}Playground.ts`
   - Must include methods for all major contract operations
   - Must include `showState()` method to display contract state

2. **Update Main Playground**: Add the new contract to the main playground script
   - Update `scripts/playground/playground.ts` to include new contract
   - Add example operations (commented out for reference)

3. **Update Interactive Playground**: Add commands for the new contract
   - Update `scripts/playground/interactive.ts` with new commands
   - Add help text for new commands

4. **Update Documentation**: Update playground README
   - Add usage examples for new contract
   - Document new commands and methods

### Example Pattern

When adding a new contract (e.g., `SlashingEngine`):

```typescript
// scripts/playground/SlashingEnginePlayground.ts
export class SlashingEnginePlayground {
  private slashingEngine: SlashingEngine;
  
  async showState(): Promise<void> {
    // Display contract state
  }
  
  async slash(account: SignerWithAddress, amount: string): Promise<void> {
    // Implement slash operation
  }
  
  // ... other methods
}
```

Then update `playground.ts`:

```typescript
const slashingPlayground = await createSlashingEnginePlayground();
await slashingPlayground.showState();
```

### Checklist

When adding a new contract, ensure:

- [ ] Playground class created (`{ContractName}Playground.ts`)
- [ ] Main playground script updated
- [ ] Interactive playground commands added
- [ ] README documentation updated
- [ ] Example operations included
- [ ] All major contract functions have playground methods
- [ ] State inspection implemented
- [ ] Error handling included

### Rationale

Playgrounds are essential for:
- **Testing**: Quick testing of contract functionality
- **Learning**: Understanding contract behavior
- **Debugging**: Interactive debugging of contract interactions
- **Documentation**: Living examples of contract usage
- **Integration**: Testing contract interactions

### Enforcement

This rule is enforced during code review. PRs adding new contracts without playground support will be requested to add it before merging.

## Contract Completion Verification Rule

**CRITICAL**: Before marking a contract as "complete", you MUST verify it matches documentation completely.

### Rule

After implementing a contract (including tests, deployment scripts, playground), you MUST:

1. **Compare Implementation with Documentation**: Line-by-line verification
2. **Verify All Documented Features**: Ensure nothing is missing
3. **Verify No Undocumented Features**: Ensure nothing extra exists (unless approved)
4. **Update Documentation**: If any discrepancies found, update documentation first

### Verification Process

#### Step 1: Feature Comparison

Create a comparison table:

| Documented Feature | Implemented? | Notes |
|-------------------|--------------|-------|
| Function: transfer() | ✅ Yes | Matches spec |
| Function: approve() | ✅ Yes | Matches spec |
| Event: Transfer | ✅ Yes | Emitted correctly |
| State: balances | ✅ Yes | Exists |
| Access Control: onlyOwner | ✅ Yes | Enforced |
| Error: "Insufficient balance" | ✅ Yes | Reverts correctly |

#### Step 2: Implementation Audit

List all implementation features and verify documentation:

| Implementation Feature | Documented? | Approved Deviation? | Notes |
|------------------------|-------------|---------------------|-------|
| Function: transfer() | ✅ Yes | - | Matches |
| Function: customHelper() | ❌ No | ❌ No | **MUST ASK or REMOVE** |

#### Step 3: Documentation Update

If discrepancies found:
1. **If documented but not implemented**: Implement it
2. **If implemented but not documented**: 
   - If approved deviation: Update documentation
   - If not approved: Ask for approval or remove feature

### Checklist

Before marking contract as "complete":

**Documentation Compliance**:
- [ ] All documented functions implemented
- [ ] All documented events emitted
- [ ] All documented state variables exist
- [ ] All documented access controls enforced
- [ ] All documented error conditions handled
- [ ] All documented workflows supported
- [ ] Implementation matches documentation exactly

**Undocumented Features Check**:
- [ ] No undocumented functions (unless approved)
- [ ] No undocumented events (unless approved)
- [ ] No undocumented state variables (unless approved)
- [ ] No undocumented access controls (unless approved)
- [ ] All features are either documented or explicitly approved

**Documentation Updates**:
- [ ] Contract specification updated (if changes made)
- [ ] Related documentation updated
- [ ] NatSpec comments match implementation
- [ ] Code comments accurate

### Example Verification Script

```typescript
// Verification checklist for TOSS contract
const verification = {
  documentedFunctions: [
    "transfer",
    "approve", 
    "transferFrom",
    "burn",
    "snapshot",
    "setGovernance",
    "setAuthorizedBurner"
  ],
  
  implementedFunctions: [
    // List all functions in contract
  ],
  
  check: () => {
    // Verify each documented function is implemented
    // Verify each implemented function is documented
    // Report discrepancies
  }
};
```

### Enforcement

- Contract cannot be marked "complete" without verification
- Code review will verify documentation compliance
- PRs with undocumented features will be rejected
- PRs missing documented features will be requested to implement them

## Contract Development Standards

### Code Organization

- Follow the established contract structure in `contracts/`
- Use consistent naming conventions
- Include comprehensive NatSpec documentation

### Testing Requirements

- Unit tests for all functions
- Integration tests for contract interactions
- zkSync-specific tests where applicable
- Minimum 90% code coverage

## Unit Test Requirements

**CRITICAL**: When adding a new contract, you MUST write comprehensive unit tests that adhere to the contract documentation.

### Rule

Every new contract MUST have corresponding unit tests that:
1. Follow the contract documentation specifications
2. Test all functions and edge cases
3. Achieve minimum 90% code coverage
4. Follow established test patterns

### Requirements

1. **Test File Location**: `test/unit/{category}/{ContractName}.test.ts`
   - Follow the directory structure matching contract location
   - Example: `contracts/core/TOSS.sol` → `test/unit/core/TOSS.test.ts`

2. **Test Structure**: Follow the pattern of `TOSS.test.ts`
   ```typescript
   describe("ContractName", () => {
     describe("Deployment", () => {
       // Deployment tests
     });
     
     describe("FunctionName", () => {
       // Function-specific tests
     });
     
     describe("Security", () => {
       // Security and access control tests
     });
   });
   ```

3. **Documentation Adherence**: Tests MUST verify:
   - All documented functions work as specified
   - All documented events are emitted correctly
   - All documented access controls are enforced
   - All documented edge cases are handled
   - All documented error conditions revert correctly

4. **Test Coverage**: Must cover:
   - Happy paths for all functions
   - Edge cases (zero values, max values, boundary conditions)
   - Error conditions (invalid inputs, unauthorized access)
   - State transitions
   - Event emissions
   - Access control (modifiers)

5. **Test Helpers**: Use existing test helpers from `test/helpers/`
   - `getTestAccounts()` - Get test accounts
   - `deployContract()` - Deploy contracts
   - `increaseTime()` - Manipulate time
   - Other helpers as needed

### Example Pattern

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { getTestAccounts, deployContract } from "../../helpers";
import type { ContractName } from "../../../typechain-types";

describe("ContractName", () => {
  let contract: ContractName;
  let accounts: any;
  let addresses: any;

  beforeEach(async () => {
    const testAccounts = await getTestAccounts();
    accounts = testAccounts.accounts;
    addresses = testAccounts.addresses;

    contract = await deployContract<ContractName>(
      "ContractName",
      [/* constructor args */],
      accounts.deployer
    );
  });

  describe("Deployment", () => {
    it("Should deploy with correct initial values", async () => {
      // Test initial state matches documentation
    });
  });

  describe("DocumentedFunction", () => {
    it("Should work as documented", async () => {
      // Test documented behavior
    });
    
    it("Should emit documented event", async () => {
      // Test event emission
    });
    
    it("Should revert with documented error", async () => {
      // Test error conditions
    });
  });
});
```

### Checklist

- [ ] Test file created in correct location
- [ ] All documented functions tested
- [ ] All documented events tested
- [ ] All documented errors tested
- [ ] Access control tests included
- [ ] Edge cases covered
- [ ] Minimum 90% coverage achieved
- [ ] Tests follow established patterns
- [ ] Test helpers used appropriately

## Integration Test Requirements

**CRITICAL**: When adding a new contract, you MUST write integration tests that verify contract interactions and adhere to documentation.

### Rule

Every new contract MUST have integration tests that:
1. Test interactions with other contracts
2. Follow integration test documentation patterns
3. Verify multi-contract workflows
4. Test real-world usage scenarios

### Requirements

1. **Test File Location**: `test/integration/{ContractName}.integration.test.ts`
   - Example: `test/integration/TOSS.integration.test.ts`

2. **Test Structure**: Follow the pattern of `TOSS.integration.test.ts`
   ```typescript
   describe("ContractName Integration Tests", function () {
     describe("ContractA Integration", () => {
       // Test interactions with ContractA
     });
     
     describe("ContractB Integration", () => {
       // Test interactions with ContractB
     });
     
     describe("Multi-Contract Scenarios", () => {
       // Test complex workflows
     });
   });
   ```

3. **Documentation Adherence**: Integration tests MUST verify:
   - Documented contract interactions work correctly
   - Documented workflows complete successfully
   - Documented integration patterns are followed
   - Documented dependencies are handled correctly

4. **Integration Scenarios**: Must test:
   - Contract-to-contract calls
   - Multi-step workflows
   - State synchronization between contracts
   - Event propagation across contracts
   - Error handling in integrated scenarios

5. **Use `loadFixture`**: Use Hardhat's `loadFixture` for efficient test setup
   ```typescript
   import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
   
   async function deployFixture() {
     // Setup contracts
     return { contract1, contract2 };
   }
   
   it("should integrate correctly", async function () {
     const { contract1, contract2 } = await loadFixture(deployFixture);
     // Test integration
   });
   ```

### Example Pattern

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-network-helpers";
import type { ContractName, RelatedContract } from "../../typechain-types";

describe("ContractName Integration Tests", function () {
  async function deployFixture() {
    const [deployer, user1, user2] = await ethers.getSigners();
    
    const RelatedContractFactory = await ethers.getContractFactory("RelatedContract");
    const relatedContract = await RelatedContractFactory.deploy();
    await relatedContract.waitForDeployment();
    
    const ContractFactory = await ethers.getContractFactory("ContractName");
    const contract = await ContractFactory.deploy(await relatedContract.getAddress());
    await contract.waitForDeployment();
    
    return { contract, relatedContract, deployer, user1, user2 };
  }

  describe("RelatedContract Integration", function () {
    it("Should interact with RelatedContract as documented", async function () {
      const { contract, relatedContract } = await loadFixture(deployFixture);
      // Test documented interaction
    });
  });
});
```

### Checklist

- [ ] Integration test file created
- [ ] All documented contract interactions tested
- [ ] Multi-contract workflows tested
- [ ] State synchronization verified
- [ ] Event propagation tested
- [ ] Error handling in integrations tested
- [ ] `loadFixture` used for efficiency
- [ ] Tests follow established patterns

## Deployment Script Requirements

**CRITICAL**: When adding a new contract, you MUST create deployment scripts that follow established patterns and documentation.

### Rule

Every new contract MUST have deployment scripts that:
1. Follow the deployment documentation patterns
2. Support multiple networks (local, testnet, mainnet)
3. Handle constructor arguments correctly
4. Save deployment information
5. Support verification

### Requirements

1. **Deployment Script Location**: `scripts/deploy/deploy{ContractName}.ts`
   - Example: `scripts/deploy/deployTOSS.ts`

2. **Script Structure**: Follow the pattern of `deployTOSS.ts`
   ```typescript
   interface ContractDeploymentConfig {
     // Configuration interface
   }
   
   interface ContractDeploymentResult {
     address: string;
     contract: ContractType;
     deploymentTx: string;
     blockNumber: number;
   }
   
   export async function deployContractName(
     config: ContractDeploymentConfig
   ): Promise<ContractDeploymentResult> {
     // Deployment logic
   }
   
   async function main() {
     // Main deployment script
   }
   ```

3. **Documentation Adherence**: Deployment scripts MUST:
   - Use constructor arguments as documented
   - Handle dependencies as documented
   - Follow deployment order as documented
   - Support documented configuration options

4. **Network Support**: Must support:
   - Local network (`--network hardhat` or `--network zkSyncLocal`)
   - Testnet (`--network zkSyncTestnet`)
   - Mainnet (when ready)

5. **Environment Variables**: Use environment variables for configuration
   ```typescript
   const config = {
     param1: process.env.CONTRACT_PARAM1 || defaultValue,
     param2: process.env.CONTRACT_PARAM2 || defaultValue,
   };
   ```

6. **Deployment Info Saving**: Save deployment information
   ```typescript
   const deploymentInfo = {
     contract: "ContractName",
     address: result.address,
     network: network.name,
     chainId: network.chainId.toString(),
     deployer: await deployer.getAddress(),
     deploymentTx: result.deploymentTx,
     blockNumber: result.blockNumber,
     timestamp: new Date().toISOString(),
     config: { /* configuration used */ },
   };
   
   fs.writeFileSync(deploymentFile, JSON.stringify(deploymentInfo, null, 2));
   ```

7. **Post-Deployment Setup**: If needed, create setup script
   - Location: `scripts/deploy/setup{ContractName}.ts`
   - Example: `scripts/deploy/setupTOSS.ts`

8. **Verification Script**: Create verification script
   - Location: `scripts/deploy/verify{ContractName}.ts`
   - Example: `scripts/deploy/verifyTOSS.ts`

9. **Package.json Scripts**: Add deployment scripts to `package.json`
   ```json
   {
     "scripts": {
       "deploy:contractname": "hardhat run scripts/deploy/deployContractName.ts",
       "deploy:contractname:local": "hardhat run scripts/deploy/deployContractName.ts --network zkSyncLocal",
       "deploy:contractname:testnet": "hardhat run scripts/deploy/deployContractName.ts --network zkSyncTestnet",
       "setup:contractname": "hardhat run scripts/deploy/setupContractName.ts",
       "verify:contractname": "hardhat run scripts/deploy/verifyContractName.ts"
     }
   }
   ```

10. **Update Main Deploy Script**: Add to `scripts/deploy/deploy.ts`
    ```typescript
    // Deploy ContractName
    const { contractName } = await deployContractName(config);
    addresses.ContractName = await contractName.getAddress();
    ```

### Example Pattern

```typescript
import { ethers } from "hardhat";
import * as fs from "fs";
import * as path from "path";
import type { ContractName } from "../../typechain-types";

interface ContractDeploymentConfig {
  param1: string;
  param2: string;
  optionalParam?: string;
}

interface ContractDeploymentResult {
  address: string;
  contract: ContractName;
  deploymentTx: string;
  blockNumber: number;
}

export async function deployContractName(
  config: ContractDeploymentConfig
): Promise<ContractDeploymentResult> {
  console.log("=== Deploying ContractName ===\n");

  const [deployer] = await ethers.getSigners();
  const network = await ethers.provider.getNetwork();

  // Validate configuration
  if (!ethers.isAddress(config.param1)) {
    throw new Error("Invalid param1 address");
  }

  console.log("Configuration:");
  console.log("  Param1:", config.param1);
  console.log("  Param2:", config.param2);
  console.log("  Network:", network.name, `(Chain ID: ${network.chainId})\n`);

  // Deploy contract
  const ContractFactory = await ethers.getContractFactory("ContractName");
  const contract = await ContractFactory.deploy(
    config.param1,
    config.param2
  );

  await contract.waitForDeployment();
  const address = await contract.getAddress();
  const deploymentTx = contract.deploymentTransaction();
  const receipt = await deploymentTx?.wait();

  if (!receipt) {
    throw new Error("Deployment transaction receipt not found");
  }

  console.log("✅ ContractName deployed to:", address);
  console.log("   Block number:", receipt.blockNumber);
  console.log("   Gas used:", receipt.gasUsed.toString(), "\n");

  return {
    address,
    contract: contract as ContractName,
    deploymentTx: deploymentTx?.hash || "",
    blockNumber: receipt.blockNumber,
  };
}

async function main() {
  const [deployer] = await ethers.getSigners();
  const network = await ethers.provider.getNetwork();

  const config: ContractDeploymentConfig = {
    param1: process.env.CONTRACT_PARAM1 || (await deployer.getAddress()),
    param2: process.env.CONTRACT_PARAM2 || "defaultValue",
    optionalParam: process.env.CONTRACT_OPTIONAL_PARAM,
  };

  const result = await deployContractName(config);

  // Save deployment info
  const addressesDir = path.join(__dirname, "../../deployments");
  if (!fs.existsSync(addressesDir)) {
    fs.mkdirSync(addressesDir, { recursive: true });
  }

  const deploymentFile = path.join(
    addressesDir,
    `ContractName-${network.name}-${network.chainId}.json`
  );

  const deploymentInfo = {
    contract: "ContractName",
    address: result.address,
    network: network.name,
    chainId: network.chainId.toString(),
    deployer: await deployer.getAddress(),
    deploymentTx: result.deploymentTx,
    blockNumber: result.blockNumber,
    timestamp: new Date().toISOString(),
    config,
  };

  fs.writeFileSync(deploymentFile, JSON.stringify(deploymentInfo, null, 2));
  console.log("Deployment info saved to:", deploymentFile);
}

if (require.main === module) {
  main()
    .then(() => process.exit(0))
    .catch((error) => {
      console.error(error);
      process.exit(1);
    });
}
```

### Checklist

- [ ] Deployment script created (`deploy{ContractName}.ts`)
- [ ] Configuration interface defined
- [ ] Constructor arguments handled correctly
- [ ] Network support (local, testnet, mainnet)
- [ ] Environment variables used
- [ ] Deployment info saved to file
- [ ] Setup script created (if needed)
- [ ] Verification script created
- [ ] Package.json scripts added
- [ ] Main deploy script updated
- [ ] Documentation updated
- [ ] Follows established patterns

### Enforcement

All three requirements (Unit Tests, Integration Tests, Deployment Scripts) are enforced during code review. PRs adding new contracts without these components will be requested to add them before merging.

## End-to-End (E2E) Test Maintenance Rule

**CRITICAL**: When a contract is completed, you MUST update E2E tests to include the new contract and verify related contract interactions.

### Rule

After completing a new contract (including unit tests, integration tests, and deployment scripts), you MUST:

1. **Identify Related Contracts**: Determine which existing contracts interact with the new contract
2. **Update E2E Tests**: Add or update E2E test scenarios that include the new contract
3. **Verify Complete Workflows**: Ensure end-to-end user journeys work with the new contract
4. **Test Contract Relationships**: Verify interactions between related contracts

### Requirements

1. **E2E Test Location**: `test/e2e/{scenario}.e2e.test.ts`
   - Example: `test/e2e/fundLifecycle.e2e.test.ts`
   - Example: `test/e2e/investorJourney.e2e.test.ts`
   - Example: `test/e2e/governanceWorkflow.e2e.test.ts`

2. **Test Structure**: E2E tests should follow this pattern:
   ```typescript
   describe("Complete {Workflow} E2E", () => {
     it("should complete full {workflow} with {newContract}", async () => {
       // 1. Setup: Deploy all related contracts
       // 2. Execute: Complete user journey/workflow
       // 3. Verify: Check final state and outcomes
     });
   });
   ```

3. **Documentation Adherence**: E2E tests MUST verify:
   - Complete workflows documented in protocol documentation
   - User journeys work end-to-end
   - Related contracts interact correctly
   - System state is consistent after workflows

4. **Related Contract Identification**: When adding a new contract, identify:
   - **Dependencies**: Contracts this contract depends on
   - **Dependents**: Contracts that depend on this contract
   - **Interactions**: Contracts that interact with this contract
   - **Workflows**: User journeys that involve this contract

5. **E2E Test Scenarios**: Must test:
   - Complete user journeys (investor, FM, governance)
   - Multi-contract workflows
   - State transitions across contracts
   - Error recovery in E2E scenarios
   - Edge cases in complete workflows

6. **Update Existing E2E Tests**: If the new contract affects existing workflows:
   - Update existing E2E test files
   - Add new test cases for new contract integration
   - Verify existing workflows still work
   - Add regression tests if needed

### Example: Adding SlashingEngine Contract

When `SlashingEngine` is completed:

1. **Identify Related Contracts**:
   - TOSS (burns tokens)
   - RiskEngine (provides fault data)
   - FundManagerVault (may be slashed)
   - Governance (authorizes slashing)

2. **Update E2E Tests**:
   ```typescript
   // test/e2e/slashingWorkflow.e2e.test.ts
   describe("Complete Slashing Workflow E2E", () => {
     it("should complete full slashing workflow", async () => {
       // 1. Setup: Deploy TOSS, RiskEngine, SlashingEngine, FundManagerVault
       const toss = await deployTOSS();
       const riskEngine = await deployRiskEngine();
       const slashingEngine = await deploySlashingEngine(toss.address, riskEngine.address);
       const vault = await deployFundManagerVault();
       
       // 2. Setup: Authorize SlashingEngine in TOSS
       await toss.setAuthorizedBurner(slashingEngine.address, true);
       
       // 3. Execute: FM creates fund and stakes TOSS
       await toss.transfer(fm.address, stakeAmount);
       await toss.connect(fm).approve(vault.address, stakeAmount);
       await vault.connect(fm).createFund(config, stakeAmount);
       
       // 4. Execute: Risk violation occurs
       await riskEngine.recordViolation(fundId, violationData);
       
       // 5. Execute: Slashing occurs
       await slashingEngine.slash(fundId, slashAmount);
       
       // 6. Verify: TOSS burned correctly
       const newSupply = await toss.totalSupply();
       expect(newSupply).to.be.lt(initialSupply);
       
       // 7. Verify: FM stake reduced
       const newStake = await vault.getStake(fundId);
       expect(newStake).to.be.lt(stakeAmount);
     });
   });
   ```

3. **Update Related E2E Tests**:
   ```typescript
   // test/e2e/fundLifecycle.e2e.test.ts
   describe("Complete Fund Lifecycle E2E", () => {
     it("should handle fund lifecycle with slashing", async () => {
       // Existing test updated to include SlashingEngine
       // Test that slashing doesn't break fund lifecycle
     });
   });
   ```

### Checklist

When completing a contract, ensure:

- [ ] Related contracts identified
- [ ] E2E test file created or updated
- [ ] Complete workflows tested
- [ ] User journeys verified
- [ ] Related contract interactions tested
- [ ] Existing E2E tests updated (if affected)
- [ ] Regression tests added (if needed)
- [ ] Documentation workflows verified

### E2E Test Categories

E2E tests should cover these categories:

1. **Investor Journeys**:
   - Complete onboarding → investment → withdrawal
   - Multiple fund investments
   - Staking and unstaking TOSS
   - Access tier progression

2. **Fund Manager Journeys**:
   - Fund creation → trading → fee collection
   - Stake management
   - Risk management
   - Fund closure

3. **Governance Workflows**:
   - Proposal creation → voting → execution
   - Parameter updates
   - Emergency actions
   - Multi-level governance

4. **System Workflows**:
   - Complete fund lifecycle
   - Slashing workflows
   - Treasury operations
   - Bridge operations

5. **Integration Workflows**:
   - Cross-contract state synchronization
   - Event propagation
   - Error recovery
   - State consistency

### Example E2E Test Structure

```typescript
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture, time } from "@nomicfoundation/hardhat-network-helpers";

describe("Complete {Workflow} E2E", function () {
  async function deployCompleteSystem() {
    const [deployer, fm, investor1, investor2, governance] = await ethers.getSigners();
    
    // Deploy all related contracts
    const toss = await deployTOSS();
    const riskEngine = await deployRiskEngine();
    const slashingEngine = await deploySlashingEngine();
    const vault = await deployFundManagerVault();
    // ... other contracts
    
    return {
      contracts: { toss, riskEngine, slashingEngine, vault },
      accounts: { deployer, fm, investor1, investor2, governance }
    };
  }

  describe("Complete User Journey", function () {
    it("should complete full workflow with {newContract}", async function () {
      const { contracts, accounts } = await loadFixture(deployCompleteSystem);
      
      // Step 1: Initial setup
      // Step 2: Execute workflow
      // Step 3: Verify outcomes
      // Step 4: Check state consistency
    });
  });

  describe("Related Contract Interactions", function () {
    it("should handle {newContract} interaction with {relatedContract}", async function () {
      // Test specific interaction
    });
  });
});
```

### Documentation References

E2E tests should verify workflows documented in:
- `docs/docs/protocol/processes/end-to-end-flow.md`
- Contract-specific documentation
- Integration guides
- User journey documentation

### Enforcement

This rule is enforced during code review. When a contract is marked as "complete", E2E tests must be updated before the PR is merged. PRs missing E2E test updates will be requested to add them.

### Security

- Security review required before mainnet deployment
- Use OpenZeppelin contracts where possible
- Follow best practices for access control
- Implement proper error handling

### Documentation

- NatSpec comments for all public functions
- README for complex contracts
- Usage examples in playground
- Integration guides for dependent contracts

## English-Only Code Rule

**CRITICAL**: All code, comments, logs, documentation, and project files MUST be in English only.

### Rule

The entire codebase, including but not limited to:
- Code comments
- Console logs and print statements
- Documentation files (README, MD files)
- Error messages
- Variable names (use English)
- Function names (use English)
- Commit messages
- Code review comments

MUST be written in English. No Turkish or other non-English languages are allowed in the codebase.

### Requirements

1. **Code Comments**: All comments in Solidity and TypeScript files must be in English
   ```solidity
   // ✅ Good: English comment
   // Deploy TOSS token contract
   
   // ❌ Bad: Turkish comment
   // TOSS token kontratını deploy et
   ```

2. **Console Logs**: All console.log, console.error, etc. must be in English
   ```typescript
   // ✅ Good
   console.log("Deploying TOSS token...");
   
   // ❌ Bad
   console.log("TOSS token deploy ediliyor...");
   ```

3. **Documentation Files**: All .md files must be in English
   - README.md
   - Documentation files
   - Guides
   - Checklists

4. **Error Messages**: All error messages must be in English
   ```solidity
   // ✅ Good
   require(amount > 0, "Amount must be greater than zero");
   
   // ❌ Bad
   require(amount > 0, "Miktar sıfırdan büyük olmalı");
   ```

5. **Variable and Function Names**: Use English names
   ```typescript
   // ✅ Good
   const initialHolder = await deployer.getAddress();
   
   // ❌ Bad
   const ilkSahip = await deployer.getAddress();
   ```

6. **NatSpec Comments**: All NatSpec must be in English
   ```solidity
   /// @notice Transfers tokens from one address to another
   /// @param from The address to transfer from
   /// @param to The address to transfer to
   /// @param amount The amount to transfer
   ```

### Enforcement

- Code review will reject PRs with non-English content
- Linting should catch non-English strings (if configured)
- Pre-commit hooks should check for non-English content

## Code Quality and Linting Rule

**CRITICAL**: All code MUST pass linting checks before being considered complete. Linting errors MUST be fixed before committing code.

### Rule

1. **After Every Development Session**: Run linting checks
2. **Before Committing**: Ensure all linting errors are resolved
3. **Automated Checks**: Use pre-commit hooks or post-development scripts

### Requirements

#### 1. Linting Commands

```bash
# Check all linting issues
yarn lint

# Check TypeScript linting
yarn lint:ts

# Check Solidity linting
yarn lint:sol

# Auto-fix formatting issues
yarn format
```

#### 2. Pre-Development Checklist

Before starting development:
- [ ] Ensure linting tools are installed
- [ ] Review existing linting configuration
- [ ] Understand linting rules

#### 3. Post-Development Checklist

After completing development:
- [ ] Run `yarn lint` to check for errors
- [ ] Fix all linting errors (not warnings)
- [ ] Run `yarn format` to auto-fix formatting
- [ ] Verify code still compiles and tests pass
- [ ] Commit only when linting passes

#### 4. Automated Linting

The following scripts automatically run linting:
- `posttest`: Runs linting after tests
- `postcompile`: Runs linting after compilation

#### 5. Linting Rules

**TypeScript/JavaScript**:
- ESLint for code quality
- Prettier for formatting
- TypeScript strict mode enabled
- No `any` types (warnings allowed for zkSync compatibility)

**Solidity**:
- Solhint for code quality
- Prettier for formatting
- Custom errors preferred over require statements (warnings)

#### 6. Ignored Files

The following build artifacts are ignored by Git and linting:
- `artifacts/` and `artifacts-zk/` - Compiled contract artifacts
- `cache/` and `cache-zk/` - Build cache
- `typechain-types/` - Generated TypeScript types
- `deployments-zk/` - zkSync deployment artifacts

### Enforcement

- **Pre-commit**: Linting must pass before committing
- **CI/CD**: Automated linting checks in CI pipeline
- **Code Review**: PRs with linting errors will be rejected
- **Development Workflow**: Run `yarn lint` after every development session
- All new code must be in English

### Migration

When fixing existing non-English content:
1. Identify all non-English strings
2. Translate to English
3. Maintain same meaning and context
4. Update all related documentation
5. Ensure consistency across the codebase

### Checklist

Before submitting code:
- [ ] All comments are in English
- [ ] All console logs are in English
- [ ] All documentation is in English
- [ ] All error messages are in English
- [ ] All variable/function names are in English
- [ ] All NatSpec is in English
- [ ] No Turkish characters in code
